scaleFUN <- function(x) sprintf("%.5f", x)
rev <- regressiondata$HDI
ggplot(data = melt(rev), aes(x = value)) +
stat_density() +
ggtitle("Plot of HDI Distribution") +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_continuous(labels=scales::dollar_format()) +
scale_y_continuous(labels=scaleFUN) +
geom_vline(xintercept = mean(rev), linetype="dotted",
color = "red", size=1.5)
library(reshape)
scaleFUN <- function(x) sprintf("%.5f", x)
rev <- regressiondata$GDPCAP
ggplot(data = melt(rev), aes(x = value)) +
stat_density() +
ggtitle("Plot of GDPCAP Distribution") +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_continuous(labels=scales::dollar_format()) +
scale_y_continuous(labels=scaleFUN) +
geom_vline(xintercept = mean(rev), linetype="dotted",
color = "red", size=1.5)
par(mfrow=c(2,2))
plot(m2)
regressiondata$HDI = as.integer(regressiondata$HDI)
regressiondata$GDPCAP = as.integer(regressiondata$GDPCAP)
gdp.glm <- glm(GDPCAP ~TC + STI+ TD + HDI, family="poisson", data=regressiondata)
summary(gdp.glm)
mu <- mean(regressiondata$GDPCAP)
plot(log(fitted(gdp.glm)),log((regressiondata$GDPCAP-fitted(gdp.glm))^2),xlab=expression(hat(mu)),ylab=expression((y-hat(mu))^2),pch=20,col="blue")
abline(0,1)
dp = sum(residuals(gdp.glm,type ="pearson")^2)/gdp.glm$df.residual
print(dp)
regressiondata$HDI = as.factor(regressiondata$HDI)
gdp.glm <- glm(GDPCAP ~TC + STI+ TD + HDI, family="poisson", data=regressiondata)
regressiondata$HDI = as.integer(regressiondata$HDI)
regressiondata$GDPCAP = as.integer(regressiondata$GDPCAP)
gdp.glm <- glm(GDPCAP ~TC + STI+ TD + HDI, family="poisson", data=regressiondata)
summary(gdp.glm)
mu <- mean(regressiondata$GDPCAP)
plot(log(fitted(gdp.glm)),log((regressiondata$GDPCAP-fitted(gdp.glm))^2),xlab=expression(hat(mu)),ylab=expression((y-hat(mu))^2),pch=20,col="blue")
abline(0,1)
dp = sum(residuals(gdp.glm,type ="pearson")^2)/gdp.glm$df.residual
print(dp)
regressiondata$HDI = as.integer(regressiondata$HDI)
regressiondata$GDPCAP = as.integer(regressiondata$GDPCAP)
gdp.glm <- glm(GDPCAP ~TC + STI+ TD + mortality_rate + TYPE + PHASE, family="poisson", data=regressiondata)
summary(gdp.glm)
mu <- mean(regressiondata$GDPCAP)
plot(log(fitted(gdp.glm)),log((regressiondata$GDPCAP-fitted(gdp.glm))^2),xlab=expression(hat(mu)),ylab=expression((y-hat(mu))^2),pch=20,col="blue")
abline(0,1)
dp = sum(residuals(gdp.glm,type ="pearson")^2)/gdp.glm$df.residual
print(dp)
library(MASS)
rev.glm <- glm.nb(GDPCAP ~TC + STI+ TD + mortality_rate + TYPE + PHASE,data=regressiondata , maxit = 100)
summary(rev.glm)
plot(rev.glm)
head(regressiondata)
m2<-lm(HDI~ TC + STI+ GDPCAP+ TD:TYPE,data=regressiondata)
summary(m2)
regressiondata$HDI = as.integer(regressiondata$HDI)
regressiondata$GDPCAP = as.integer(regressiondata$GDPCAP)
gdp.glm <- glm(GDPCAP ~TC + STI+ TD + mortality_rate + TYPE + PHASE, family="poisson", data=regressiondata)
summary(gdp.glm)
mu <- mean(regressiondata$GDPCAP)
plot(log(fitted(gdp.glm)),log((regressiondata$GDPCAP-fitted(gdp.glm))^2),xlab=expression(hat(mu)),ylab=expression((y-hat(mu))^2),pch=20,col="blue")
abline(0,1)
dp = sum(residuals(gdp.glm,type ="pearson")^2)/gdp.glm$df.residual
print(dp)
library(MASS)
rev.glm <- glm.nb(GDPCAP ~TC + STI+ TD + mortality_rate + TYPE + PHASE,data=regressiondata , maxit = 100)
summary(rev.glm)
plot(rev.glm)
library(MASS)
regressiondata$TYPE = as.factor(regressiondata$TYPE)
rev.glm <- glm.nb(GDPCAP ~TC + STI+ TD + mortality_rate + TYPE + PHASE,data=regressiondata , maxit = 100)
summary(rev.glm)
plot(rev.glm)
regressiondata$TYPE
return(n)
#We use the raw data in sheet 2 for data processing. The transformed data is ill structured. For instance ln1 is 0 and missing values were also assigned value 0.
library("readxl")
library("dplyr")
rawdata <- read_excel("COVID.xlsx", sheet = "Sheet2",col_names=T,range = cell_cols(1:9))
colnames(rawdata)<-c("CODE","COUNTRY",	"DATE",	"TC",	"TD","STI",	"POP","GDPCAP","HDI")
#a function take natrual log and leave 0 if the cell is 0 and NA if the cell is NA
avoid_zero_ln<-function(x){
n=ifelse(x == 0, 0, log(x))
return(n)
}
data<-rawdata %>% mutate_at(c("TC",	"TD","STI",	"POP","GDPCAP"), avoid_zero_ln)
colnames(data)<-c("CODE","COUNTRY",	"DATE",	"logTC",	"logTD","logSTI",	"logPOP","logGDPCAP","HDI")
#keep both variables in log scale and original ones.
#The processed data is  called covid. Note that NA values are perserved.
covid<-cbind(data,rawdata[,c(4:8)])
head(covid)
#function to calculate mortality rate, return 0 if no case or if no death
mrate<-function(td,tc){
if (td==0){mortality<-0}
else{mortality<-td/tc}
return (mortality)
}
# Time Phase
begin_phase = as.Date("2020-02-01", format = "%Y-%m-%d")
dev_phase = as.Date("2020-05-01", format = "%Y-%m-%d")
outbreak_phase = as.Date("2020-07-01", format = "%Y-%m-%d")
regressiondata <- covid %>%  mutate(PHASE = case_when(
DATE<=begin_phase ~ 0,
DATE> begin_phase &DATE <=dev_phase ~ 1,
DATE>=dev_phase ~ 2
))%>% filter(DATE==begin_phase |DATE==dev_phase|DATE==outbreak_phase)
# 0 = UNDERDEVELOPED, 1 = DEVELOPING, 2 = DEVELOPED
regressiondata$TYPE[regressiondata$GDPCAP<5338.454]<- 0
regressiondata$TYPE[regressiondata$GDPCAP>= 5338.454 & regressiondata$GDPCAP<31400.840]<- 1
covid$TYPE[covid$GDPCAP>=31400.840 ]<- 2
regressiondata<-drop_na(regressiondata)
regressiondata$mortality_rate<-as.vector(mapply(mrate,regressiondata$TD,regressiondata$TC))*100
regressiondata$PHASE<-as.factor(regressiondata$PHASE)
regressiondata$TYPE<-as.factor(regressiondata$TYPE)
regressiondata$GDP<- regressiondata$POP *regressiondata$GDPCAP
regressiondata$logGDP<- log(regressiondata$POP *regressiondata$GDPCAP)
head(regressiondata)
regressiondata$HDI = as.integer(regressiondata$HDI)
regressiondata$GDPCAP = as.integer(regressiondata$GDPCAP)
gdp.glm <- glm(GDPCAP ~TC + STI+ TD + mortality_rate + TYPE + PHASE, family="poisson", data=regressiondata)
summary(gdp.glm)
mu <- mean(regressiondata$GDPCAP)
plot(log(fitted(gdp.glm)),log((regressiondata$GDPCAP-fitted(gdp.glm))^2),xlab=expression(hat(mu)),ylab=expression((y-hat(mu))^2),pch=20,col="blue")
abline(0,1)
dp = sum(residuals(gdp.glm,type ="pearson")^2)/gdp.glm$df.residual
print(dp)
regressiondata$TYPE
library(MASS)
rev.glm <- glm.nb(GDPCAP ~TC + STI+ TD + mortality_rate + TYPE + PHASE,data=regressiondata , maxit = 100)
summary(rev.glm)
plot(rev.glm)
# Time Phase
begin_phase = as.Date("2020-02-01", format = "%Y-%m-%d")
dev_phase = as.Date("2020-05-01", format = "%Y-%m-%d")
outbreak_phase = as.Date("2020-07-01", format = "%Y-%m-%d")
regressiondata <- covid %>%  mutate(PHASE = case_when(
DATE<=begin_phase ~ 0,
DATE> begin_phase &DATE <=dev_phase ~ 1,
DATE>=dev_phase ~ 4
))%>% filter(DATE==begin_phase |DATE==dev_phase|DATE==outbreak_phase)
# 0 = UNDERDEVELOPED, 1 = DEVELOPING, 2 = DEVELOPED
regressiondata$TYPE[regressiondata$GDPCAP<5338.454]<- 0
regressiondata$TYPE[regressiondata$GDPCAP>= 5338.454 & regressiondata$GDPCAP<31400.840]<- 1
covid$TYPE[covid$GDPCAP>=31400.840 ]<- 2
regressiondata<-drop_na(regressiondata)
regressiondata$mortality_rate<-as.vector(mapply(mrate,regressiondata$TD,regressiondata$TC))*100
regressiondata$PHASE<-as.factor(regressiondata$PHASE)
regressiondata$TYPE<-as.factor(regressiondata$TYPE)
regressiondata$GDP<- regressiondata$POP *regressiondata$GDPCAP
regressiondata$logGDP<- log(regressiondata$POP *regressiondata$GDPCAP)
head(regressiondata)
library(MASS)
rev.glm <- glm.nb(GDPCAP ~TC + STI+ TD + mortality_rate + TYPE + PHASE,data=regressiondata , maxit = 100)
summary(rev.glm)
plot(rev.glm)
# Time Phase
begin_phase = as.Date("2020-02-01", format = "%Y-%m-%d")
dev_phase = as.Date("2020-05-01", format = "%Y-%m-%d")
outbreak_phase = as.Date("2020-07-01", format = "%Y-%m-%d")
regressiondata <- covid %>%  mutate(PHASE = case_when(
DATE<=begin_phase ~ 0,
DATE> begin_phase &DATE <=dev_phase ~ 1,
DATE>=dev_phase ~ 2
))%>% filter(DATE==begin_phase |DATE==dev_phase|DATE==outbreak_phase)
# 0 = UNDERDEVELOPED, 1 = DEVELOPING, 2 = DEVELOPED
regressiondata$TYPE[regressiondata$GDPCAP<5338.454]<- 0
regressiondata$TYPE[regressiondata$GDPCAP>= 5338.454 & regressiondata$GDPCAP<31400.840]<- 1
covid$TYPE[covid$GDPCAP>=31400.840 ]<- 2
regressiondata<-drop_na(regressiondata)
regressiondata$mortality_rate<-as.vector(mapply(mrate,regressiondata$TD,regressiondata$TC))*100
regressiondata$PHASE<-as.factor(regressiondata$PHASE)
regressiondata$TYPE<-as.factor(regressiondata$TYPE)
regressiondata$GDP<- regressiondata$POP *regressiondata$GDPCAP
regressiondata$logGDP<- log(regressiondata$POP *regressiondata$GDPCAP)
head(regressiondata)
library(MASS)
rev.glm <- glm.nb(GDPCAP ~TC + STI+ TD + mortality_rate + TYPE + PHASE,data=regressiondata , maxit = 100)
summary(rev.glm)
plot(rev.glm)
regressiondata$GDPCAP = as.integer(regressiondata$GDPCAP)
rev.glm <- glm.nb(GDPCAP ~TC + STI+ TD + mortality_rate + TYPE + PHASE,data=regressiondata , maxit = 100)
summary(rev.glm)
plot(rev.glm)
library(MASS)
regressiondata$GDPCAP = as.integer(regressiondata$GDPCAP)
rev.glm <- glm.nb(GDPCAP ~TC + STI+ TD + mortality_rate + TYPE + PHASE,data=regressiondata , maxit = 100)
summary(rev.glm)
plot(rev.glm)
library(MASS)
regressiondata$GDPCAP = as.integer(regressiondata$GDPCAP)
rev.glm <- glm.nb(GDPCAP ~TC + STI+ TD + HDI + mortality_rate + TYPE + PHASE,data=regressiondata , maxit = 100)
summary(rev.glm)
plot(rev.glm)
library("dplyr")
library('forecast')
library(tidyverse)
library(leaps)
library(ggplot2)
library(reshape)
library(chron)
admission = read.csv("../data/final_csv/final.csv")
admission$plan_date <- as.Date(admission$plan_date , format = "%Y-%m-%d")
admission$transaction_date <- as.Date(admission$transaction_date , format = "%Y-%m-%d")
admission = subset(admission, select = -c(Date) )
head(admission)
# unique(admission$transaction_date)
admission$Radius = as.numeric(admission$Radius)
mean(admission$Radius, na.rm = TRUE)
COVID_START <-  as.Date("2020-02-01" , format = "%Y-%m-%d")
by_day <- admission %>%
group_by(transaction_date) %>%
summarise(
adm_count = sum(quantity),
revenue = sum(extension),
cat_general = sum(quantity[category == 'ADMISSION ']),
cat_combo = sum(quantity[category == 'COMBOADMIS']),
# Item
adult = sum(quantity[item == 'ADULT     ']),
youth = sum(quantity[item =='YOUTH     ']),
child = sum(quantity[item=='CHILD     ']),
senior = sum(quantity[item=='SENIOR    ']),
child4 = sum(quantity[item=='CHILD4    ']),
avg_pcsplit_2 = mean(pcsplit_2),
teacher = sum(quantity[item=='TEACHER   ']),
driver = sum(quantity[item=='DRIVER    ']),
avg_transaction_time = mean(times(transaction_time)),
total_michigan = sum(quantity[STATE =="MI"  ]),
###
avg_pr_ctr_1 = mean(pr_ctr_1),
avg_pcsplit_1 = mean(pcsplit_1),
avg_pr_ctr_2 = mean(pr_ctr_2),
total_primary = sum(quantity[MARKET =="Primary"  ]),
total_secondary = sum(quantity[MARKET =="Secondary"  ]),
total_core = sum(quantity[MARKET =="Core"  ]),
total_not_michigan = sum(quantity[STATE !="MI"  ]),
prcp = mean(PRCP_in),
snow = mean(SNOW),
tmax = mean(TMAX_F),
tmin = mean(TMIN_F),
avg_purchase_window = mean(adv_purchase_window),
avg_gas_price = mean(price_per_gallon),
num_discounts = sum(quantity[str_length(special) > 0]),
total_discount_amt = sum(disc_amt),
avg_radius = mean(Radius, na.rm = TRUE),
# Exhibits attendance
towers_attendance = sum(quantity[towers_of_tomorrow == 1]),
house_attendance = sum(quantity[house_industries == 1]),
eames_attendance = sum(quantity[charles_and_ray_Eames == 1]),
am_style_attendance = sum(quantity[american_style == 1]),
end_ideal_attendance = sum(quantity[enduring_ideals == 1]),
eng_exp_attendance = sum(quantity[engines_exposed == 1]),
pixar_attendance = sum(quantity[pixar == 1]),
star_trek_attendance = sum(quantity[star_trek == 1]),
no_exhibit_attendance = sum(quantity[exhibit_total == 0]),
total_exhibit_attendance = sum(quantity[exhibit_total >= 1]),
towers_revenue = sum(extension[towers_of_tomorrow == 1]),
house_revenue = sum(extension[house_industries == 1]),
eames_revenue = sum(extension[charles_and_ray_Eames == 1]),
am_style_revenue = sum(extension[american_style == 1]),
end_ideal_revenue = sum(extension[enduring_ideals == 1]),
eng_exp_revenue = sum(extension[engines_exposed == 1]),
pixar_revenue = sum(extension[pixar == 1]),
star_trek_revenue = sum(extension[star_trek == 1]),
no_exhibit_revenue = sum(extension[exhibit_total == 0]),
total_exhibit_revenue = sum(extension[exhibit_total >= 1]),
main_exhibit_type = first(main_type)
) %>%
filter(transaction_date < COVID_START)
by_day
# remove date and filter negative values and convert to integers
df <- by_day[by_day$revenue >= 0, ]
# df<- subset(df, select = -c(transaction_date) )
df$revenue <- as.integer(df$revenue)
# df <- na.omit(df)
head(df)
# df <- by_day[by_day$adm_count >= 0, ]
# # df<- by_day # comment out for analysis
# df<- subset(df, select = -c(transaction_date) )
# df$adm_count <- as.integer(df$adm_count)
# df <- na.omit(df)
# head(df)
COVID_START <-  as.Date("2020-02-01" , format = "%Y-%m-%d")
by_day <- admission %>%
group_by(transaction_date) %>%
summarise(
adm_count = sum(quantity),
revenue = sum(extension),
cat_general = sum(quantity[category == 'ADMISSION ']),
cat_combo = sum(quantity[category == 'COMBOADMIS']),
# Item
adult = sum(quantity[item == 'ADULT     ']),
youth = sum(quantity[item =='YOUTH     ']),
child = sum(quantity[item=='CHILD     ']),
senior = sum(quantity[item=='SENIOR    ']),
child4 = sum(quantity[item=='CHILD4    ']),
avg_pcsplit_2 = mean(pcsplit_2),
teacher = sum(quantity[item=='TEACHER   ']),
driver = sum(quantity[item=='DRIVER    ']),
avg_transaction_time = mean(times(transaction_time)),
total_michigan = sum(quantity[STATE =="MI"  ]),
###
avg_pr_ctr_1 = mean(pr_ctr_1),
avg_pcsplit_1 = mean(pcsplit_1),
avg_pr_ctr_2 = mean(pr_ctr_2),
total_primary = sum(quantity[MARKET =="Primary"  ]),
total_secondary = sum(quantity[MARKET =="Secondary"  ]),
total_core = sum(quantity[MARKET =="Core"  ]),
total_not_michigan = sum(quantity[STATE !="MI"  ]),
prcp = mean(PRCP_in),
snow = mean(SNOW),
tmax = mean(TMAX_F),
tmin = mean(TMIN_F),
avg_purchase_window = mean(adv_purchase_window),
avg_gas_price = mean(price_per_gallon),
num_discounts = sum(quantity[str_length(special) > 0]),
total_discount_amt = sum(disc_amt),
avg_radius = mean(Radius, na.rm = TRUE),
# Exhibits attendance
towers_attendance = sum(quantity[towers_of_tomorrow == 1]),
house_attendance = sum(quantity[house_industries == 1]),
eames_attendance = sum(quantity[charles_and_ray_Eames == 1]),
am_style_attendance = sum(quantity[american_style == 1]),
end_ideal_attendance = sum(quantity[enduring_ideals == 1]),
eng_exp_attendance = sum(quantity[engines_exposed == 1]),
pixar_attendance = sum(quantity[pixar == 1]),
star_trek_attendance = sum(quantity[star_trek == 1]),
no_exhibit_attendance = sum(quantity[exhibit_total == 0]),
total_exhibit_attendance = sum(quantity[exhibit_total >= 1]),
towers_revenue = sum(extension[towers_of_tomorrow == 1]),
house_revenue = sum(extension[house_industries == 1]),
eames_revenue = sum(extension[charles_and_ray_Eames == 1]),
am_style_revenue = sum(extension[american_style == 1]),
end_ideal_revenue = sum(extension[enduring_ideals == 1]),
eng_exp_revenue = sum(extension[engines_exposed == 1]),
pixar_revenue = sum(extension[pixar == 1]),
star_trek_revenue = sum(extension[star_trek == 1]),
no_exhibit_revenue = sum(extension[exhibit_total == 0]),
total_exhibit_revenue = sum(extension[exhibit_total >= 1]),
main_exhibit_type = first(main_type)
) %>%
filter(transaction_date < COVID_START)
# remove date and filter negative values and convert to integers
df <- by_day[by_day$revenue >= 0, ]
# df<- subset(df, select = -c(transaction_date) )
df$revenue <- as.integer(df$revenue)
# df <- na.omit(df)
head(df)
# df <- by_day[by_day$adm_count >= 0, ]
# # df<- by_day # comment out for analysis
# df<- subset(df, select = -c(transaction_date) )
# df$adm_count <- as.integer(df$adm_count)
# df <- na.omit(df)
# head(df)
COVID_START <-  as.Date("2020-02-01" , format = "%Y-%m-%d")
by_day <- admission %>%
group_by(transaction_date) %>%
summarise(
adm_count = sum(quantity),
revenue = sum(extension),
cat_general = sum(quantity[category == 'ADMISSION ']),
cat_combo = sum(quantity[category == 'COMBOADMIS']),
# Item
adult = sum(quantity[item == 'ADULT     ']),
youth = sum(quantity[item =='YOUTH     ']),
child = sum(quantity[item=='CHILD     ']),
senior = sum(quantity[item=='SENIOR    ']),
child4 = sum(quantity[item=='CHILD4    ']),
avg_pcsplit_2 = mean(pcsplit_2),
teacher = sum(quantity[item=='TEACHER   ']),
driver = sum(quantity[item=='DRIVER    ']),
avg_transaction_time = mean(times(transaction_time)),
total_michigan = sum(quantity[STATE =="MI"  ]),
###
avg_pr_ctr_1 = mean(pr_ctr_1),
avg_pcsplit_1 = mean(pcsplit_1),
avg_pr_ctr_2 = mean(pr_ctr_2),
total_primary = sum(quantity[MARKET =="Primary"  ]),
total_secondary = sum(quantity[MARKET =="Secondary"  ]),
total_core = sum(quantity[MARKET =="Core"  ]),
total_not_michigan = sum(quantity[STATE !="MI"  ]),
prcp = mean(PRCP_in),
snow = mean(SNOW),
tmax = mean(TMAX_F),
tmin = mean(TMIN_F),
avg_purchase_window = mean(adv_purchase_window),
avg_gas_price = mean(price_per_gallon),
num_discounts = sum(quantity[str_length(special) > 0]),
total_discount_amt = sum(disc_amt),
avg_radius = mean(Radius, na.rm = TRUE),
# Exhibits attendance
towers_attendance = sum(quantity[towers_of_tomorrow == 1]),
house_attendance = sum(quantity[house_industries == 1]),
eames_attendance = sum(quantity[charles_and_ray_Eames == 1]),
am_style_attendance = sum(quantity[american_style == 1]),
end_ideal_attendance = sum(quantity[enduring_ideals == 1]),
eng_exp_attendance = sum(quantity[engines_exposed == 1]),
pixar_attendance = sum(quantity[pixar == 1]),
star_trek_attendance = sum(quantity[star_trek == 1]),
no_exhibit_attendance = sum(quantity[exhibit_total == 0]),
total_exhibit_attendance = sum(quantity[exhibit_total >= 1]),
towers_revenue = sum(extension[towers_of_tomorrow == 1]),
house_revenue = sum(extension[house_industries == 1]),
eames_revenue = sum(extension[charles_and_ray_Eames == 1]),
am_style_revenue = sum(extension[american_style == 1]),
end_ideal_revenue = sum(extension[enduring_ideals == 1]),
eng_exp_revenue = sum(extension[engines_exposed == 1]),
pixar_revenue = sum(extension[pixar == 1]),
star_trek_revenue = sum(extension[star_trek == 1]),
no_exhibit_revenue = sum(extension[exhibit_total == 0]),
total_exhibit_revenue = sum(extension[exhibit_total >= 1]),
main_exhibit_type = first(main_type))
# ) %>%
# filter(transaction_date < COVID_START)
write.csv(by_day,"../data/final_csv/by_day.csv", row.names = FALSE)
# remove date and filter negative values and convert to integers
# df <- by_day[by_day$revenue >= 0, ]
# df<- subset(df, select = -c(transaction_date) )
# df$revenue <- as.integer(df$revenue)
# df <- na.omit(df)
# head(df)
# df <- by_day[by_day$adm_count >= 0, ]
# # df<- by_day # comment out for analysis
# df<- subset(df, select = -c(transaction_date) )
# df$adm_count <- as.integer(df$adm_count)
# df <- na.omit(df)
# head(df)
library("MASS")
#use robust regression method
robust_regression_m1<-rlm(GDPCAP ~ TC+TD +logPOP+HDI+ STI:TYPE+STI:PHASE, data = regressiondata)
summary(robust_regression_m1)
regression_m1<-lm(GDPCAP ~ TC+TD +logPOP+HDI+ STI:TYPE+STI:PHASE, data = regressiondata)
summary(regression_m1)
library("dplyr")
library('forecast')
library(tidyverse)
library(leaps)
library(ggplot2)
library(reshape)
library(chron)
admission = read.csv("../data/final_csv/final.csv")
admission$plan_date <- as.Date(admission$plan_date , format = "%Y-%m-%d")
admission$transaction_date <- as.Date(admission$transaction_date , format = "%Y-%m-%d")
admission = subset(admission, select = -c(Date) )
admission$Radius = as.numeric(admission$Radius)
head(admission)
# unique(admission$transaction_date)
## For Candle Stick
temp = read.csv("../../mike_temp/final_quarter.csv")
candle  <- temp %>%
group_by(transaction_date) %>%
summarise(
admis = sum(quantity),
reven = sum(extension)
)
candle
## For Candle Stick
temp = read.csv("../../mike_temp/final_quarter.csv")
temp$transaction_date <- as.Date(temp$transaction_date , format = "%Y-%m-%d")
temp <- temp %>%
order_by(transaction_date)
temp <- temp %>%
arrange(transaction_date)
head(temp)
temp
head(temp)
type.rf <- randomForest(TYPE ~ ., data=regressiondata, importance=TRUE,
proximity=TRUE)
library(randomforest)
install.packages("randomForest")
library(randomforest)
library('randomforest')
library(randomForest)
type.rf <- randomForest(TYPE ~ ., data=regressiondata, importance=TRUE,
proximity=TRUE)
round(importance(type.rf), 2)
head(regressiondata)
round(importance(type.rf), 2)
type.rf <- randomForest(TYPE ~ logTC + logTD + logSTI + logPOP + logGDPCAP + HDI + TC + TD +STI +POP + GDPCAP + PHASE +
mortality_rate + GDP + logGDP, data=regressiondata, importance=TRUE,
proximity=TRUE)
round(importance(type.rf), 2)
MDSplot(type.rf, regressiondata$TYPE)
round(importance(type.rf), 2, k = 4)
round(importance(type.rf), 2, k = 3)
round(importance(type.rf), 2, k = 2)
round(importance(type.rf), 2, k = 1)
MDSplot(type.rf, regressiondata$TYPE, k = 4)
set.seed(1)
data(iris)
iris.rf <- randomForest(Species ~ ., iris, proximity=TRUE,
keep.forest=FALSE)
MDSplot(iris.rf, iris$Species)
## Using different symbols for the classes:
MDSplot(iris.rf, iris$Species, palette=rep(1, 3), pch=as.numeric(iris$Species))
MDSplot(type.rf, regressiondata$TYPE, k = 7)
MDSplot(type.rf, regressiondata$TYPE, k = 15)
MDSplot(type.rf, regressiondata$TYPE, k = 2)
MDSplot(type.rf, regressiondata$TYPE, k = 3)
MDSplot(type.rf, regressiondata$TYPE)
data(iris)
iris
unique(iris$Species)
# Stratified sampling
type.rf2 <- randomForest(TYPE ~ logTC + logTD + logSTI + logPOP + logGDPCAP + HDI + TC + TD +STI +POP + GDPCAP + PHASE +
mortality_rate + GDP + logGDP, data=regressiondata,
sampsize=c(20, 30, 20))
round(importance(type.rf2), 2)
round(importance(type.rf), 2)
