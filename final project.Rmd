---
title: "final project"
author: "Jiayi Guo, Ziqu Wang, Yuanhao Zhu, Yuhan Hu, Michael Russo"
date: "4/18/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
##data processing

```{r}
#We use the raw data in sheet 2 for data processing. The transformed data is ill structured. For instance ln1 is 0 and missing values were also assigned value 0. 
library("readxl")
library("dplyr")
rawdata <- read_excel("COVID.xlsx", sheet = "Sheet2",col_names=T,range = cell_cols(1:9))
colnames(rawdata)<-c("CODE","COUNTRY",	"DATE",	"TC",	"TD","STI",	"POP","GDPCAP","HDI")
#a function take natrual log and leave 0 if the cell is 0 and NA if the cell is NA 
avoid_zero_ln<-function(x){
 n=ifelse(x == 0, 0, log(x))
 return(n)
}

data<-rawdata %>% mutate_at(c("TC",	"TD","STI",	"POP","GDPCAP"), avoid_zero_ln)
colnames(data)<-c("CODE","COUNTRY",	"DATE",	"logTC",	"logTD","logSTI",	"logPOP","logGDPCAP","HDI")
#keep both variables in log scale and original ones. 
#The processed data is  called covid. Note that NA values are perserved. 
covid<-cbind(data,rawdata[,c(4:8)])
head(covid)
```

>Data are in both natural log and original scale. 

| Variable Indicator   | Description  | Measurement |
| ------------- |:-------------:| :-----:|
| STI    | Stringency Index | COVID-19 PandemicLockdown |
|  TC    | Total Cases      |  COVID-19 PandemicTotal cases recorded  |
| TD | Total Death     | COVID-19 PandemicDeaths-   |
|  GDPCAP   | GDP Per Capital      |  Economic Growth  |
| HDI | Human Development Index      |  Poverty Alleviation |


```{r}
library("ggplot2")
theme_set(theme_bw())
library("sf")
library("rnaturalearth")
library("rnaturalearthdata")
library("maps")
world_map <- map_data("world")
```



```{r}
world_map <- map_data("world")
deathrate<-c()
for( i in unique(covid$COUNTRY)){
  d<-covid[covid$COUNTRY==i,11]
  p<-covid[covid$COUNTRY==i,13]
  if(all(is.na(p)) |all(is.na(d)) ){rate<-NA}
  else{
  totaldeath<-max(d,na.rm=T)
  population<-max(p,na.rm = T)
  rate<-(totaldeath/population)*100}
  deathrate<-c(deathrate,rate)
}
d_rate<-data.frame(region=unique(covid$COUNTRY), deathrate)
levels(d_rate$region)[levels(d_rate$region)=="United States"] <- "USA"
```

```{r}
comb <- left_join(world_map,d_rate, by = "region")
ggplot(comb, aes(long, lat, group = group))+
  geom_polygon(aes(fill = deathrate ), color = "white")+
  scale_fill_viridis_c(
  alpha = 0.7,
  begin = 0,
  end = 1,
  direction = -1,
  option = "A",
  values = NULL,
  space = "Lab",
  na.value = "grey80",
  guide = "colourbar",
  aesthetics = "fill"
)+labs(title="World Map of Total Death Rate for Each Country",
        x ="Longitude", y = "Latitude7")

```

```{r}
# plot trend of covid cases and death world wide
sub_covid<-covid[,c('DATE',"TC","TD")]

sub_covid$FDATE<-as.factor(sub_covid$DATE)
world_cases<-aggregate(TC~FDATE, data=sub_covid, FUN=sum ,na.action=na.omit)
world_death<-aggregate(TD~FDATE, data=sub_covid, FUN=sum ,na.action=na.omit)
world_death<-subset(world_death, select = -c(1) )
world_cd<-cbind(world_cases,world_death)
world_cd$logTC<-log(world_cd$TC)
world_cd$logTD<-log(world_cd$TD)
ggplot(data = world_cd, aes(x = as.Date(FDATE))) +
  geom_line(aes(y = logTC, colour = "logTC")) +
  geom_line(aes(y = logTD, colour = "logTD")) +
  scale_colour_manual("", values = c("logTC"="green", "logTD"="red")) +
  xlab("time") +
  ylab("log counts")+
  labs(title="total cases and deaths worldwide in log scale")


```
```{r}
#plot correlation between GDP VS STI AND 
deathrate<-c()
for( i in unique(covid$COUNTRY)){
  d<-covid[covid$COUNTRY==i,11]
  p<-covid[covid$COUNTRY==i,13]
  if(all(is.na(p)) |all(is.na(d)) ){rate<-NA}
  else{
  totaldeath<-max(d,na.rm=T)
  population<-max(p,na.rm = T)
  rate<-(totaldeath/population)*100}
  deathrate<-c(deathrate,rate)
}
```

```{r}
#correlation of total death vs HDI is different for underdeveloped developing and developed countries, result of the paper may be wrong! 
quantile(covid$GDPCAP,na.rm=T)
bygdp<-covid[,c('COUNTRY',"TD","GDPCAP","HDI")]
bygdp$type[bygdp$GDPCAP<5338.454]<-"UNDERDEVELOPED"
bygdp$type[bygdp$GDPCAP> 5338.454 &bygdp$GDPCAP<31400.840]<-"DEVELOPING"
bygdp$type[bygdp$GDPCAP>31400.840 ]<-"DEVELOPED"
ud<-bygdp[bygdp$type=="UNDERDEVELOPED",]
d<-bygdp[bygdp$type=="DEVELOPING",]
dd<-bygdp[bygdp$type=="DEVELOPED",]
ud_corr<-cor(ud$TD,ud$HDI,use="pairwise.complete.obs")
d_corr<-cor(d$TD,d$HDI,use="pairwise.complete.obs")
dd_corr<-cor(dd$TD,dd$HDI,use="pairwise.complete.obs")
ud_p<-cor.test(ud$TD,ud$HDI,use="pairwise.complete.obs")$p.value
d_p<-cor.test(d$TD,d$HDI,use="pairwise.complete.obs")$p.value
dd_p<-cor.test(dd$TD,dd$HDI,use="pairwise.complete.obs")$p.value
data.frame(type=c("underdeveloped","developing","developed"),corrs=c(ud_corr,d_corr,dd_corr),pval=c(ud_p,d_p,dd_p))
```
> In comparison to the paper, we find although in general total death has a positive correlation with HDI, the effect is insignificant for developing country, but is significant for underdeveloped, developed countries. Thus, we can think population control may not be a good idea for developing countries. Also for further regression analysis , we may need to create indicator variable for the degree of developement  for countries. 

##Regression part
```{r}
library(tidyverse)
```

```{r}
covid$DATE <- as.Date(covid$DATE , format = "%Y-%m-%d")

#function to calculate mortality rate, return 0 if no case or if no death 
mrate<-function(td,tc){
  if (td==0){mortality<-0}
  else{mortality<-td/tc}
  return (mortality)
  
}
```


```{r}
# Time Phase
begin_phase = as.Date("2020-02-01", format = "%Y-%m-%d")
dev_phase = as.Date("2020-05-01", format = "%Y-%m-%d")
outbreak_phase = as.Date("2020-07-01", format = "%Y-%m-%d")
regressiondata <- covid %>%  mutate(PHASE = case_when(
  DATE<=begin_phase ~ 0,
  DATE> begin_phase &DATE <=dev_phase ~ 1,
  DATE>=dev_phase ~ 2
))%>% filter(DATE==begin_phase |DATE==dev_phase|DATE==outbreak_phase)
regressiondata$TYPE[regressiondata$GDPCAP<5338.454]<-"UNDERDEVELOPED"
regressiondata$TYPE[regressiondata$GDPCAP>= 5338.454 & regressiondata$GDPCAP<31400.840]<-"DEVELOPING"
covid$TYPE[covid$GDPCAP>=31400.840 ]<-"DEVELOPED"
regressiondata<-drop_na(regressiondata)
regressiondata$mortality_rate<-as.vector(mapply(mrate,regressiondata$TD,regressiondata$TC))*100
regressiondata$PHASE<-as.factor(regressiondata$PHASE)
regressiondata$TYPE<-as.factor(regressiondata$TYPE)
regressiondata$GDP<- regressiondata$POP *regressiondata$GDPCAP
regressiondata$logGDP<- log(regressiondata$POP *regressiondata$GDPCAP)
head(regressiondata)
```

```{r}

library(corrplot)
corrdata <- regressiondata[c(9:18) ]
corrdata$TYPE <- as.numeric(factor(corrdata$TYPE))
corrdata$PHASE <-as.numeric(corrdata$PHASE)
cor1 = cor(corrdata)
corrplot.mixed(cor1, lower.col = 'black', number.cex = .7)
```


##Regression Analysis
```{r}
library("MASS")
#use robust regression method 
robust_regression_m1<-rlm(GDPCAP ~ TC+TD +logPOP+HDI+ STI:TYPE+STI:PHASE, data = regressiondata)
summary(robust_regression_m1)
regression_m1<-lm(GDPCAP ~ TC+TD +logPOP+HDI+ STI:TYPE+STI:PHASE, data = regressiondata)
summary(regression_m1)
```
```{r}
stepAIC(regression_m1,direction="both")
```

```{r}
regression_m1_final<-lm(GDPCAP ~ TC+TD +logPOP+HDI+ STI:TYPE, data = regressiondata)
summary(regression_m1_final)
```


> Based on our first regression model, we want to investigate the association between STI and GDP per capita. We created three addtional varaible, one is type, which indicates whether a country is developed/ developing or underdeveloped based on gdp per capita. The other variable is phase, which divide the covid period into three main phases: 0 is initial phase, 1 is developing phase, 2 is total outbreak phase. . We created these additional variables in order to study the relationship between STI and GDP per capita in different types of countries and different phases of covid 19. 
> Our first model regresses GDP per capita against total death, total case, log population, HDI and interaction between STI and type of country and interaction between STI and phase of covid. Thus the formula of our model is ： 

GDPCAP = $\beta_1 *TC +\beta_2*TD+\beta_3*logPOP +\beta_4*HDI+ \beta_5*STI*developed+\beta_6*STI*developing +\beta_7*STI*underdeveloped +\beta_8*STI*PHASE1+\beta_9*STI*PHASE2$

> We further used stepwise AIC method for variable selection and found that the STI:PHASE interaction term cannot add siginificant additional information to our model. Thus, we deleted them. Thus, the relationship between STI and GPD per capita is same for all phases of covid19. 

> From the above result, we saw that the inference of covariates of both robust and ordinary least square method are consistent. We saw that there is a positive association between total case and GDPCAP, indicating that economic growth and total case number have a positive association. It makes sense that, the more active and developed the economy, the more easier for the virus to transmit among people due to human-human interactions. Total death is negatively associated with GDP per capita. Thus, we can interpret it as the more developed the economy is, the better medical care the country can provide, thus reducing the total death. Population is negatively associated with GDP per capita. Therefore, too much population can negatively impact the economic growth. The stringency index is positively associated with gdp per capital for developed countries and have negative association for  developing and underdeveloped countries. Given it is a developed country, the higher the STI, the higher the GDP per capita. given it is a underdeveloped/ developing country, the higher the STI, the lower the GDP per capita. Thus, for the developed countries,the active economy requires the government to apply much stricter covid policy to prevent further transmission. And for developing and underdeveloped countries, those with higher GDP per capita and more active economy tend to apply less strict policy. This may due to the government chooses not to address COVID issue or the unwillingness to sacrifice the economy. 
 


```{r}
m2<-lm(HDI~ logTC + STI+ logPOP+ logTD:TYPE,data=regressiondata)
summary(m2)
m2_robust<-rlm(HDI~ logTC + STI+ logPOP+ logTD:TYPE,data=regressiondata)
summary(m2_robust)
```

```{r}
stepAIC(m2,direction="both")
```


> Our second model regresses HDI against log total cases, stringency index, log population and interaction between log total deaths and country development type. Thus the formula of our model is ：

HDI = $\beta_1 *logTC +\beta_2*STI+\beta_3*logPOP + \beta_4*logTD*developed+\beta_5*logTD*developing +\beta_6*logTD*underdeveloped $

> Similar to the GDPCAP models, we saw that both robust and ordinary least square method are consistent with the inference of covariates. Moreover, we found a positive association between log total deaths to human development index. This can be interpreted as countries with high poverty alleviation is positively correlated with COVID-19 cases. From our correlation table, we found a high correlation between HDI and GDP, thus confirming that countries with high HDI can easily spread the virus from human-to-human interactions. Additionally, we can see a negative association between HDI and STI. This seems intuitive because as the pandemic lockdown protocol becomes more strict, it also restricts businesses from operating under normal conditions. Interestingly, the human development index is positively associated with total deaths in developing countries, while negatively associated with total deaths in underdeveloping countries. With the mixed correlations, we are able to infer that COVID deaths are relative to the counties development status. Finally, we found a negative correlation between a countries population and HDI. We can assume that if a country has a larger population size, then there are more opportunities to contribute to the overall growth and wellbeing.  

> From our stepwise AIC method, the AIC score stayed within an absolute value of 2, thus confiming that removing any variables will not lead to any significant changes to our models performance. 



```{r}
head(regressiondata)
```


##logistic regression 

```{r}
quantile(regressiondata$mortality_rate)
#by literature search, the averaged covid-19 mortality rate world wide by oct 2020 is about 5%, which is at 80% quantile according to our data, mortality rate variable.

#if mortality<2.91% ,we let severity =1, between 2.91% and 4.68% let severity =2, > 4.68%, we let severity=3. severity is thus a ordinal factor variable.
regressiondata$SEVERITY[regressiondata$mortality_rate<4.68]<-0
regressiondata$SEVERITY[regressiondata$mortality_rate>=4.68]<-1
logistic_m<-glm(SEVERITY ~  logPOP:TYPE + STI + logGDPCAP+ HDI, data = regressiondata, family = binomial)
summary(logistic_m)
stepAIC(logistic_m,direction="both")
```

```{r}
#use cross validation to select threshold
library(boot)

prediction_error<-c()
threshold<-c()
for(i in seq(0.3,0.8, 0.05)){
  mycost <- function(r, pi){
    weight1 = 1 #cost for getting 1 wrong
    weight0 = 1 #cost for getting 0 wrong
    c1 = (r==1)&(pi<=i) #logical vector - true if actual 1 but predict 0
    c0 = (r==0)&(pi>i) #logical vector - true if actual 0 but predict 1
    return(mean(weight1*c1+weight0*c0))
}
  error<-cv.glm(regressiondata,logistic_m,K=5, cost=mycost)$delta[1]
  prediction_error<-c(prediction_error,error)
  threshold<-c(threshold,i)
}
error_result<-data.frame(prediction_error,threshold)
ggplot(data=error_result, aes(x=threshold, y=prediction_error)) +
  geom_line()+
  geom_point()+ labs(title="prediction errors using 5 folds cross validation \n with different threshold")
```

>We used logistic regression to study the relationship between severity of covid-19 as measured by mortality rate and GPD per capita, HDI and interaction of log population and type of country. Severity is a 0,1 factor variable created based on mortality rate. Based on our current knowledge about covid1-19 mortality rate and based on the quantile of mortality rate of our dataset, we define > 4.68% mortality rate as severe and denote as 1, otherwise we denote severity as 0 .We run a logistic regression against interaction term logPopulation:type of country, STI, logGDPCAP, and HDI. We found our the interaction terms logPopulation by type of country are  statistically significant and has reasonable effect size. We further use step wise AIC fo variable selection and found the final model only contains the interaction term. After variable selection, we use 5 fold corss validation to try to find the optimal threshold(cutoff) value for logistic regression prediction. Based on the above plot, we found that data is balanced and optima threshold is around 0.5. 
> Thus, severity of covid-19 is neither correlated with GDP per capita nor HDI. Severity is positively correlated with the interaction terms. In each category, no matter whether a country is developed, developing or underdeveloped, the larger the population, the higher the probability the covid situation is severe in this country. 
> This result is consistent with what we observed in reality. When the COVID-19 was initially found in Wuhan, China. Many people believed that developed countries, with superior medical system and technology,can successfully combat the disease. However, we actually found that the condition of covid-19 was surprisingly severe in many of the developed countries. Thus, our result is also consistent with what we observed in reality that severity has nothing to do with GDP per capita nor HDI level. 


# Decision Tree
```{r}
library(caret)
library(rpart)
library(e1071)
library(rpart.plot)

trainid = sample(nrow(regressiondata), nrow(regressiondata)*0.7, replace = FALSE)
trainingdata = regressiondata[trainid,]
testdata = regressiondata[-trainid,]

numFold = trainControl(method="cv", number = 10)
cpGrid = expand.grid(.cp = seq(0.01, 0.5, 0.01))
train(TYPE~ HDI + TC + TD +STI +POP  + PHASE +
                          mortality_rate , data=trainingdata, method = "rpart", trControl =numFold, tuneGrid = cpGrid)
treeCV = rpart(TYPE ~ HDI + TC + TD +STI +POP  + PHASE +
                          mortality_rate, data=trainingdata, method="class", cp=0.05)
predictCV = predict(treeCV, newdata=testdata, type="class")
length(predictCV)
length(testdata$TYPE)
t = table(testdata$TYPE, predictCV)
rpart.plot(treeCV)
confusionMatrix(t)
```

## Random Forest
```{r}
# library(stringr)
# library("openxlsx")
# library(data.table)
# library(corrplot)
# library(ggpubr)
# library(ggplot2)
# library(Matrix)
# library(lme4)
# library(lmerTest)
# library(factoextra)
# library(cluster)
# library(epiR)
library("gplots")
library(randomForest)
library(pROC)
```

```{r}
# Train/test split
trainid = sample(nrow(regressiondata), nrow(regressiondata)*0.7, replace = FALSE)
trainingdata = regressiondata[trainid,]
testdata = regressiondata[-trainid,]
n<-16
# Find best Mtree
m_tree <- c()
for(i in 1:(n-1)){
  mtry_fit<-randomForest(TYPE ~ logTC + logTD + logSTI + logPOP + logGDPCAP + HDI + TC + TD +STI +POP + GDPCAP + PHASE +
                          mortality_rate + GDP + logGDP, data=trainingdata, mtry=i)
  err<-mean(mtry_fit$err.rate)
  print(err)
  m_tree<- c(m_tree, err)
}
m_tree
min(m_tree)
```


```{r}
trainingdata$TYPE <- as.numeric(factor(trainingdata$TYPE))

ntree_fit<-randomForest(TYPE ~ logTC + logTD + logSTI + logPOP  + HDI + TC + TD +STI +POP  + PHASE +
                          mortality_rate , data = trainingdata, mtry = 6, ntree = 100, importance = TRUE)
plot(ntree_fit)
# legend("top", colnames(ntree_fit$err.rate),col=1:4,cex=0.8,fill=1:4)

rf = randomForest(TYPE ~ logTC + logTD + logSTI + logPOP  + HDI + TC + TD +STI +POP  + PHASE +
                          mortality_rate, data = trainingdata, mtry = 6, ntree = 20,importance = TRUE, proxmity = TRUE)
rf


importance<-importance(rf)
importance


varImpPlot(rf, main = "variable importance")

pred1<-predict(rf, data=trainingdata)
Freq1<-table(pred1, trainingdata$TYPE)
sum(diag(Freq1))/sum(Freq1)


pre <- predict(rf,newdata=testdata)

obs_p_ran = data.frame(prob=pre,obs=testdata$TYPE)

table(testdata$TYPE,pre,dnn=c("real","predict"))

ran_roc <- roc(testdata$TYPE,as.numeric(pre))
plot(ran_roc, print.auc=TRUE, auc.polygon=TRUE, grid=c(0.1, 0.2),grid.col=c("green", "red"), max.auc.polygon=TRUE,auc.polygon.col="skyblue", print.thres=TRUE,main='RandomForest ROC,mtry=4,ntree=20')
par(mfrow=c(1,2))

```





